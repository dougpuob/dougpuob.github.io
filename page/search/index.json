[{"content":"敗了一顆AMD Ryzen 9 3900X(12 Cores, 24 Threads)，把RAM置頂到192GB，編譯速度遠勝舊機器，想做些實驗留下記錄把感覺數據化。我把幾個我曾經使用過的開發環境都放入測試，主要是測試原生機與虛擬機(Windows/Linux in QEMU/KVM、LXC)在編譯LLVM專案榨乾CPU資源的同時，比較那一種花的時間比較少。\n 起因 我原本使用的Intel便當盒拿來編譯LLVM太慢，一個小改動就需要20~60分鐘的編譯時間，下班時間花在side project時間本來就不多，其中有一大半是在等待有些浪費。除了編譯還有執行測試(Regression Test與Unit Test)，整個跑完幾次後我變的愈庲愈有耐心了。耐心蓄積到上限後我還是敗了AMD Ryzen 9 3900X (3.8GHz 12 Cores, 24 Threads)，還把DRAM安裝到上限的192GB(事後發現192GB的DRAM有些浪費)，改善之後最好的情況耗時約10~15分鐘，有數倍時顯的改變。\nLLVM是跨平台的專案，每次推上去的patch後，\u0008BuildBot machines會分別在Windows與Linux作業系統上跑完編譯與測試，所以我本地端的環境也準備了兩種環境。我習慣的開發環境是Windows，Linux則是在Windows中使用VM安裝Ubuntu，之間透過SSH溝通(VSCode+Remote SSH)。一切處理好就這樣過了好一陣子，直到朋友向我提到PVE(Proxomax Virtual Environment)很像可以幫上我簡化環境，於是我開始接觸PVE，試著把我的開發環境架建在PVE。\n簡單的介紹一下PVE的用途，它使用Debian作為Host OS，整合了LXC與KVM(QEMU)的虛擬環境技術，讓我可以最大比例的共享AMD R9 3900X的硬體資源。PVE整合的非常友善，大部份的事都可以透過WebUI處理完，非常的方便。從Intel NUC始換過去的前後，我沒有特別留下編譯所需的時間，只覺得快多了卻沒有比較的數據。有了PVE後環境就更豐富，更多了LXC與KVM的虛擬環境，事情不可能只有優點，很直覺的能想的到是虛擬環境可能會與原生機有些差異，到底差多少我一直很好奇，於是就催生了這篇文章。\n下面就是我測試結果、方式\u0026amp;條件、還有結論。\n 測試結果 測試數據   結果比較(時間)\n   AMD R9 3900x Ninja-Vs2019 MSBuild-Vs2019 Ninja-Gcc Core     BareMetal-Native[SVM] 11.96 23.96 11.31 24   BareMetal-Native 17.86 26.36 14.54 12   PVE-QEMU/KVM 13.68 26.85 13.99 24   PVE-lxc x x 12.05 24   VMware-Windows10 16.3 29.79 13.64 24   VMware-Ubuntu20.4 15.58 29.7 14.31 24   BareMetal-Native 51.66 63.68 46.76 8       Intel NUC i5 Ninja-Vs2019 MSBuild-Vs2019 Ninja-Gcc Core     BareMetal-Native 51.66 63.68 46.76 8      結果比較(百分比)\n   AMD R9 3900x Ninja-Vs2019 MSBuild-Vs2019 Ninja-Gcc Core     BareMetal-Native[SVM] 106% 212% 100% 24   BareMetal-Native 158% 233% 129% 12   PVE-QEMU/KVM 121% 237% 124% 24   PVE-lxc x x 107% 24   VMware-Windows10 144% 263% 121% 24   VMware-Ubuntu20.4 15.58 263% 127% 24   BareMetal-Native 51.66 563% 413% 8       Intel NUC i5 Ninja-Vs2019 MSBuild-Vs2019 Ninja-Gcc Core     BareMetal-Native 51.66 563% 413% 8      這份測試所 \u0026hellip;\n 有的完整詳細的測試數據表，可以在這[下載]的到。 使用的時間單位都是分鐘。 使用的主要電腦是AMD Ryzen 9 3900X (3.8GHz 12 Cores, 24 Threads)。 使用的額外電腦是Intel NUC i5-10210U (1.60GHz 4 Cores, 8 Thrreads)。 指的no SVM(Secure Virtualal Machine)是指在BIOS中關掉AMD CPU的多執行緒功能(所以僅有12\u0008 Cores，沒有另外的12個\u0008Threads了)。  額外說明\n x : 無沒資料，因為LXC上不支援Visual Studio 2019。 #CPU : Cores + Threads 8 : 4 Cores + 4 Threads (on Intel CPU) 12 : Cores (on AMD CPU，no SVM) 24 : 12 Cores + 12 Threads (on AMD CPU) 32 : 32GB (Intel CPU機器上全部的記憶體) 64 : 64GB (AMD CPU機器上分配64GB給LXC/VM虛擬機使用) 192 : 192GB (AMD CPU機器上全部的記憶) Ninja-Gcc : 是在Ubuntu20.4中執行。 Ninja-Vs2019 : 是在Windows10中執行。 MSBuild-Vs2019 : 是在Windows10中執行。  長條圖 愈短愈好\n\rColumn chart\r\n 長條圖 (加入Intel NCU) 愈短愈好\n\rPie chart including Intel NUC\r\n 方法\u0026amp;條件 測試的方式很直覺，安裝完作業系統後把它更新到最新的，Windows Update或apt update然後安裝所需軟體，接下來就敲指令進行測試。其中有一項是no SVM是進到BIOS關掉SVM mode之外，我沒有為硬體多作些設定或調校。其中有些數據我重新測試後會得到不一樣的數值，我僅保留最小數值的那次。主系統上的硬碟是1TB M.2的NVMe速度是PCIe Gen3，所以Disk I/O不會是效能的瓶頸，沒進行討論。\n使用到的機器\n Intel NUC i5-10210U (1.60GHz 4 Cores, 8 Thrreads) 32GB DRAM\n(這台電腦裡有使用我們公司的IC，還有我寫的Kernel Driver，用起來有種特別的心情) AMD Ryzen 9 3900X (3.8GHz 12 Cores, 24 Threads) 128GB DRAM  虛擬機\n VMWare/Windows10的Host OS是Windows10。 VMWare/Ubuntu20.4的Host OS是Windows10。  虛擬機磁碟格式\n LXC : QCOW2 QEMU/KVM : QCOW2 VMWare : VMDK  編譯目標\n llvmorg-11.1.0  編譯指令\u0026amp;參數\n最近在嘗試PowerShell，就用它來寫腳本。\n# Ubuntu20.4(Ninja-Gcc) \u0026amp; Windows10(Ninja-Vs2019) Measure-Command { ` cmake -G \u0026#34;Ninja\u0026#34; ` -DLLVM_ENABLE_ABI_BREAKING_CHECKS=OFF ` -DLLVM_TARGETS_TO_BUILD=\u0026#34;X86\u0026#34; ` -DLLVM_ENABLE_PROJECTS=\u0026#34;clang;llvm;clang-tools-extra\u0026#34; ` -DCMAKE_BUILD_TYPE=Release ` ../llvm ` } Measure-Command { ` cmake --build . --config Release ` } # Windows10(MSBuild-Vs2019) Measure-Command { ` cmake -G \u0026#34;Visual Studio 16 2019\u0026#34; -A X64 ` -DLLVM_ENABLE_ABI_BREAKING_CHECKS=OFF ` -DLLVM_TARGETS_TO_BUILD=\u0026#34;X86\u0026#34; ` -DLLVM_ENABLE_PROJECTS=\u0026#34;clang;llvm;clang-tools-extra\u0026#34; ` -DCMAKE_BUILD_TYPE=Release ` ../llvm ` } Measure-Command { ` cmake --build . --config Release ` }  結論 整個測試大概花了2~3天完成，其中包括了等待與手殘重測所花的時間。測試中所使用到的QEMU/KVM與LXC都是基於PVE的環境，過程遇到些問題要感謝節省哥的幫助，還好有他我的PVE之路走的格外的順利。\n我大至用條列式整理我的結論：\n Native的表現不意外是最好的，LXC的表現也非常優秀，兩個數值非常相近。LXC花的時間比Native多約6%(僅Linux)。 Native在關掉SVM mode(多執行序)花的時間比Native多約10~49%。 QEMU/KVM整體的表現也不錯，但還略遜Native約12~23%。 VMWare/Ubuntu20.4花的時間比Native多約20~26%。 VMWare/Windows10花的時間比Native多約20~36%。 Intel NUC花的時間比AMD 3900X多約265~431%。與我最原始的痛點在換CPU後改善了2~4倍。  以一個開發者額外想補充的心得：\n 看百分比感覺差很多，實際上多個1~3分不會有太強烈的感覺。反到是天氣愈來愈熱有時後CPU可以到83~85度C，還沒覺得慢之前就熱到開始流汗了。 裡面我最無奈的是MSBuild-Vs2019這項最有感，明顯慢了1倍。我通常拿它看程式碼追程式碼，編譯就交給Ninja與compilers。 我全部的記憶體是192GB，編譯Release的版本大概需要32GB我覺得是甜蜜點。 接上一項，在Linux上如果linker使用lld使用到的記憶體會有明顯的下降，約10GB左右就足夠了。 使用VMWare編譯時我發現CPU的溫度會特別高，我想應該是VM程式有動態調整CPU的vcore。(沒特別是查證原因，留給自己的記錄) 最後，家裡並沒有使用PVE，我反而是把PVE應用在上班的工作中，雖然PVE增加了應用的多樣性與方便性，我例出我沒有使用原因：  家裡的機器只會有我一個人使用，分享再多的硬體資源我還是只有一個人兩雙手。 改好程式碼後同時在Windows, Linux編譯的速度不會比較快，而且失敗重試所花的時間會更久。 效能還是比原生機差一些。 最主要的原因是「我不想一次開兩台電腦」。    以上資訊僅提供參考，測試數據可能會依設定或其它因素有所不同。\n 參考資訊   AMD Ryzen™ 9 3900X 官網資訊\nhttps://www.amd.com/en/products/cpu/amd-ryzen-9-3900x\n  Intel® NUC (NUC10i5FNB)\nhttps://ark.intel.com/content/www/tw/zh/ark/products/189239/intel-nuc-10-performance-kit-nuc10i5fnh.html\n  LLVM source code\nhttps://github.com/llvm/llvm-project/tree/llvmorg-11.0.1\n  Proxmox VE Documentation\nhttps://pve.proxmox.com/pve-docs/\n  節省工具箱\nhttp://blog.jason.tools\n   ","date":"2021-05-30T11:53:06+08:00","image":"https://dougpuob.github.io/post/20210530-build-speed-comparison-btw-lxc-qemu-and-baremetal-by-llvm/index_huc0a303e03252ea8ad81583290ded3f60_537512_120x120_fill_q75_box_smart1.jpg","permalink":"https://dougpuob.github.io/post/20210530-build-speed-comparison-btw-lxc-qemu-and-baremetal-by-llvm/","title":"Build speed comparison between LXC, QEMU, and Native by LLVM"}]